{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"A Practical Introduction to the Theory of Mathematical Optimization","text":"<p>This site offers a hands-on introduction to the basics of mathematical optimization, guiding you through practical examples in constraint programming and integer programming. In constraint programming, we provide just a brief introduction, while in integer programming we dive into more advanced topics, including constraint generation, Benders decomposition, column generation, and branch-and-cut (with custom cuts).</p> <p>All examples are implemented in Python. The source codes are available at https://github.com/hmarko89/mathoptintro.</p> <p>For constraint programming, we use the Google OR-Tools CP-SAT, and for integer programming, we use the Google OR-Tools MathOpt. These can be easily installed using the following command:</p> <pre><code>python -m pip install ortools\n</code></pre> <p>Why python?</p> <p>Python is easy to learn and quick to experiment with, which makes it ideal for teaching and prototyping optimization models. At the same time, the heavy computational work is handled by highly optimized solvers written in C/C++, so using Python does not necessarily mean sacrificing performance. This allows students to focus on modeling ideas and algorithms rather than low-level implementation details.</p> <p>Why Google OR-Tools CP-SAT Solver?</p> <p>OR-Tools CP-SAT is one of the leading constraint programming solvers. Over the past two years, OR-Tools CP-SAT has won in all categories of The MiniZinc Challenge, an annual competition where CP solvers are tested on a wide variety of benchmark problems.</p> <p>Why Google OR-Tools MathOpt?</p> <p>First of all, if we already use OR-Tools for constraint programming, MathOpt is a natural choice for mathematical programming as well. Beyond that, MathOpt is an excellent tool in its own right.</p> <p>MathOpt is not a standalone solver; its key idea is the clean separation between modeling and solving. At the same time, the interface between the two enables advanced algorithmic features. The underlying solver can be easily switched (e.g., SCIP, HiGHS, Gurobi (license required)), and it is possible to implement methods such as column generation or branch-and-cut in a solver-independent way.</p> <p>As an alternative, the <code>Python-MIP</code> package can also be used. It serves a similar purpose, but supports fewer solvers (CBC and Gurobi), offers fewer callback mechanisms, and is developed less actively.</p>"},{"location":"elte/","title":"ELTE - Oper\u00e1ci\u00f3kutat\u00e1s Sz\u00e1m\u00edt\u00f3g\u00e9pes M\u00f3dszerei","text":"<p>2025/2026-os tan\u00e9v II. (tavaszi) f\u00e9l\u00e9v.</p>"},{"location":"elte/#a-targy-celja","title":"A t\u00e1rgy c\u00e9lja","text":"<p>A t\u00e1rgy c\u00e9lja, hogy a hallgat\u00f3k a f\u00e9l\u00e9v sor\u00e1n megismerkedjenek k\u00fcl\u00f6nf\u00e9le optimaliz\u00e1ci\u00f3s feladatok gyakorlati, sz\u00e1m\u00edt\u00f3g\u00e9pes megold\u00e1s\u00e1nak lehet\u0151s\u00e9geivel.</p> <p>A f\u00e9l\u00e9v nagy r\u00e9sz\u00e9ben eg\u00e9sz\u00e9rt\u00e9k\u0171 programoz\u00e1si m\u00f3dszerekkel foglalkozunk: alapvet\u0151 feladatok (h\u00e1tizs\u00e1k feladat, utaz\u00f3\u00fcgyn\u00f6k feladat, stb.); alapvet\u0151 modellez\u00e9si technik\u00e1k; v\u00e1g\u00e1s-gener\u00e1l\u00e1s (utaz\u00f3\u00fcgyn\u00f6k feladat, g\u00e9p\u00fctemez\u00e9s, stb.); oszlop-gener\u00e1l\u00e1s (szab\u00e1si feladat, stb.); stb. R\u00f6viden - p\u00e1r feladat erej\u00e9ig - sz\u00f3 lesz m\u00e9g korl\u00e1toz\u00e1s programoz\u00e1sr\u00f3l, \u00e9s lok\u00e1lis keres\u00e9sen alapul\u00f3 heurisztik\u00e1k is el\u0151ker\u00fclnek majd.</p> <p>A gyakorlatokon a feladatok megold\u00e1s\u00e1hoz a Python programoz\u00e1si nyelvet haszn\u00e1ljuk.</p>"},{"location":"elte/#kovetelmenyek","title":"K\u00f6vetelm\u00e9nyek","text":"<p>A hallgat\u00f3knak a f\u00e9l\u00e9v sor\u00e1n k\u00e9t beadand\u00f3 feladatot kell teljes\u00edteni\u00fck a gyakorlati jegy megszerz\u00e9s\u00e9hez.</p>"},{"location":"elte/#a-felev-menete","title":"A f\u00e9l\u00e9v menete","text":"<p>Cs\u00fct\u00f6rt\u00f6k 8:30-10:00, D 3.105 (Grafika labor) | Ha valaki a saj\u00e1t laptopj\u00e1n szeretn\u00e9 az \u00f3rai munk\u00e1t v\u00e9gezni, nyugodtan hozza mag\u00e1val. S\u0151t!</p> <p><p>[1] 2026.02.05. (Regisztr\u00e1ci\u00f3s id\u0151szak)</p></p> <p>[2] 2026.02.12.</p> <p>Korl\u00e1toz\u00e1s programoz\u00e1s: bevezet\u00e9s, <code>alldifferent</code> constraint.</p> <p><code>sendmoremoney.py</code> <code>sudoku.py</code> <code>queens.py</code></p> <p>[3] 2026.02.19.</p> <p>Korl\u00e1toz\u00e1s programoz\u00e1s: interval variables, non-overlapping constraints.</p> <p><code>scheduling.py</code> (<code>scheduling_instances.py</code>) <code>rectangle.py</code></p> <p>[4] 2026.02.26.</p> <p>[5] 2026.03.05.</p> <p>[6] 2026.03.12.</p> <p>[7] 2026.03.19.</p> <p>[8] 2026.03.26.</p> <p><p>[9] 2026.04.02. (Tavaszi sz\u00fcnet)</p></p> <p>[10] 2026.04.09.</p> <p>[11] 2026.04.16.</p> <p>[12] 2026.04.23.</p> <p>[13] 2026.04.30.</p> <p><p>[14] 2026.05.07. (E\u00f6tv\u00f6s nap)</p></p> <p>[15] 2026.05.14.</p>"},{"location":"elte/#elerhetoseg","title":"El\u00e9rhet\u0151s\u00e9g","text":"<p>\ud83d\udce7 marko.horvath (kukac) sztaki (pont) hu</p> <p>\ud83d\udccd SZTAKI (1111 Budapest, Kende utca 13-17.), K518</p> <p>\ud83d\udcc5 Fogad\u00f3\u00f3r\u00e1k el\u0151re egyeztetett id\u0151pontban.</p>"},{"location":"elte/#technikai-dolgok","title":"Technikai dolgok","text":""},{"location":"elte/#visual-studio-code","title":"Visual Studio Code","text":"<p>Az \u00f3r\u00e1n Visual Studio Code-ban mutatom a p\u00e9ld\u00e1kat, de persze, mindenki haszn\u00e1lhatja a kedvenc szerkeszt\u0151j\u00e9t.</p>"},{"location":"elte/#python","title":"Python","text":"<p>A k\u00f6vetkez\u0151 csomagokat fogjuk haszn\u00e1lni:</p>"},{"location":"elte/#google-or-tools","title":"Google OR-Tools","text":"<p>Korl\u00e1toz\u00e1s programoz\u00e1shoz a CP-SAT-ot, eg\u00e9sz\u00e9rt\u00e9k\u0171 programoz\u00e1shoz a MathOpt csomagot haszn\u00e1ljuk majd. <pre><code>python -m pip install ortools\n</code></pre></p> <p>A MathOpt j\u00f3 p\u00e1r solver-t t\u00e1mogat, de ezek nem mindegyike j\u00f6n automatikusan a telep\u00edt\u00e9skor. \u00c9rdemes ez\u00e9rt telep\u00edteni valamelyiket a k\u00f6vetkez\u0151k k\u00f6z\u00fcl:</p> <ul> <li> <p>HiGHS: Ny\u00edlt forr\u00e1skod\u00f3 megold\u00f3 (MIP, QP).</p> </li> <li> <p>SCIP: Ny\u00edlt forr\u00e1skod\u00f3 megold\u00f3 (MIP, MINLP, CIP).</p> </li> <li> <p>Gurobi:     Kereskedelmi megold\u00f3, de tudtok di\u00e1k licence-t ig\u00e9nyelni hozz\u00e1.     A 12-es verzi\u00f3t \u00e9rdemes telep\u00edteni, mert a MathOpt ann\u00e1l \u00fajabbat egyel\u0151re nem t\u00e1mogat.</p> </li> </ul>"},{"location":"elte/#egyeb-csomagok","title":"Egy\u00e9b csomagok","text":"<p>Matplotlib. Rajzolni. <pre><code>python -m pip install matplotlib\n</code></pre></p> <p>NetworkX. Gr\u00e1fokhoz. <pre><code>python -m pip install networkx\n</code></pre></p>"},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#tag:cp","title":"cp","text":"<ul> <li>            Machine scheduling          </li> <li>            Rectangle packing          </li> <li>            Sudoku          </li> <li>            n-queens          </li> </ul>"},{"location":"tags/#tag:interval-variables","title":"interval variables","text":"<ul> <li>            Machine scheduling          </li> <li>            Rectangle packing          </li> </ul>"},{"location":"tags/#tag:non-overlapping-constraints","title":"non-overlapping constraints","text":"<ul> <li>            Machine scheduling          </li> <li>            Rectangle packing          </li> </ul>"},{"location":"tags/#tag:packing","title":"packing","text":"<ul> <li>            Rectangle packing          </li> </ul>"},{"location":"tags/#tag:puzzle","title":"puzzle","text":"<ul> <li>            Sudoku          </li> <li>            n-queens          </li> </ul>"},{"location":"tags/#tag:scheduling","title":"scheduling","text":"<ul> <li>            Machine scheduling          </li> <li>            Machine scheduling          </li> </ul>"},{"location":"cp/cp/","title":"Introduction to Constraint Programming","text":"<p>If you have ever solved a Sudoku puzzle, you will find it easy to understand the basics of constraint programming (CP).</p> Sudoku \u2013 How to solve it on paper? <p>In sudoku, there is a partially filled grid of size \\(9\\times 9\\). The goal is to write a number from \\(1,\\ldots,9\\) in each empty cell, such that each column, each row, and each of the nine \\(3\\times 3\\) subgrids that compose the grid contains all numbers from \\(1,\\ldots,9\\) exactly once.</p> <p>So, how would you solve such a puzzle? I bet you grab a pencil (recommended only for printed version!) and write the remaining possible values for each empty cell in small writing. For example, if a number, say 4, is definitely placed in a cell, then the number 4 can be removed from the possible values of the cells in the same row, in the same column, and in the same subgrid. If a cell ends up with only one possible value, you can write that value boldy. Depending on the difficulty of the puzzle, you may eventually reach a point where this tactic is no longer sufficient to continue solving.</p> <p>However, you can also try to eliminate impossible values using a bit of logic plus some courage and a dash of luck. Pick a cell, write one of the remaining candidate numbers lightly, and see what happens when you apply the previous elimination tactics again. If you are lucky, you will quickly find out whether you made a bad choice: some contradiction will appear \u2014 for example, a cell ends up with no valid values left according to the rules. In that case, you can safely remove the number you just tried from the cell\u2019s possible candidates. If you do not get lost in the bookkeeping, this \"trial and error\" strategy will guarantee the solution to the puzzle.</p> <p>This solving strategy sketched for Sudoku is pretty close to the classic way CP solvers tackle problems.</p>"},{"location":"cp/cp/#constraint-satisfaction-problem","title":"Constraint Satisfaction Problem","text":"<p>A constraint satisfaction problem (CSP) is defined as a triplet \\((\\mathcal{X},\\mathcal{D},\\mathcal{C})\\), where:</p> <ul> <li>\\(\\mathcal{X}=(\\mathbf{x}_1,\\ldots,\\mathbf{x}_n)\\) is a set of variables;</li> <li>\\(\\mathcal{D}=(D_1,\\ldots,D_n)\\) is the set of domains of the variables; and</li> <li>\\(\\mathcal{C}\\) is a finite set of constraints.</li> </ul> <p>A constraint \\((X,R)\\) is defined by a set \\(X = \\{ \\mathbf{x}_{i_1},\\ldots,\\mathbf{x}_{i_m} \\} \\subseteq \\mathcal{X}\\) of variables and a relation \\(R \\subseteq D_{i_1} \\times \\ldots \\times D_{i_m}\\) that defines the set of values allowed simultaneously for those variables. We distinguish three categories of constraints:</p> <ul> <li>Extensional constraints are defined by explicitly listing all allowed combinations of values for the involved variables.</li> <li>Arithmetic constraints are defined by an arithmetic expression (\\(&lt;\\), \\(\\leq\\), \\(&gt;\\), \\(\\geq\\), \\(=\\), \\(\\neq\\), etc.).</li> <li>Logical constraints are defined with an explicit logical semantics.</li> </ul> <p>The <code>alldifferent</code> constraint</p> <p>The <code>alldifferent</code> logical constraint requires that the given variables take pairwise distinct values:</p> \\[ \\operatorname{alldifferent}(\\mathbf{x}_{i_1},\\ldots,\\mathbf{x}_{i_m}) \\longleftrightarrow \\left( (\\mathbf{x}_{i_1},\\ldots,\\mathbf{x}_{i_m}), \\left\\{ (d_{i_1},\\ldots,d_{i_m}) \\subseteq D_{i_1} \\times \\ldots \\times D_{i_m} : j\\neq k \\Rightarrow d_{i_j} \\neq d_{i_k} \\right\\} \\right) \\] <p>Check the <code>alldifferent</code> constraint in the Global Constraint Catalog.</p> <p>A solution for the CSP is a total assignement \\((d_1,\\ldots,d_n)\\) of values to variables such that:</p> <ul> <li>the values are selected from the domains, that is, \\(d_i \\in D_i\\) holds for \\(i=1,\\ldots,n\\); and</li> <li>each constraint \\(((\\mathbf{x}_{i_1},\\ldots,\\mathbf{x}_{i_m}),R)\\subseteq \\mathcal{C}\\) is satisfied, that is, \\((d_{i_1},\\ldots,d_{i_m}) \\in R\\).</li> </ul> Sudoku \u2013 Modelling as a CSP <p>Note that this brief introduction is already enough to model Sudoku as a CSP. Each cell is associated with a variable, such that empty cell variables have domain \\(\\{1,\\ldots,9\\}\\), while pre-filled cell variables are fixed to their given value. For each row, each column, and each subgrid, we impose an <code>alldifferent</code> constraint to ensure that all numbers are distinct.</p> <p>For details, see the next page.</p>"},{"location":"cp/cp/#propagators","title":"Propagators","text":"<p>Each constraint is associated with a propagator, which is a process that tries to shrink the domains of the variables involved in that constraint \u2014 in other words, it removes values that cannot appear in any solution.</p> <p>Whenever the domain of a variable changes, the propagators of all constraints containing that variable are triggered, which may in turn trigger more propagator calls, and so on...</p> <p>It can happen that, at the end of this propagator-avalanche, a variable's domain becomes empty, which proves that the problem has no solution. Otherwise, we say that all constraints \u2014 and therefore the whole problem \u2014 are locally consistent.</p> Sudoku \u2013 Propagating <p>The tactic we used in Sudoku to eliminate impossible values from cells is basically the propagators of the <code>alldifferent</code> constraints in action.</p>"},{"location":"cp/cp/#local-consistency","title":"Local consistency","text":"<p>A constraint \\(((\\mathbf{x}_{i_1},\\ldots,\\mathbf{x}_{i_m}),R)\\) over \\(m\\) variables is hyper-arc consistent if for every variable \\(\\mathbf{x}_{i_k}\\) (\\(1\\leq k\\leq m\\)) and for every value \\(d \\in D_{i_k}\\) in its domain, there exists a feasible assignment \\((d_{i_1},\\ldots,d_{i_m}) \\in R\\) with \\(d_{i_k} = d\\). In other words, no value in any variable's domain can be removed based on this constraint alone.</p> <p>Node consistency (\\(m=1\\))</p> \\[   \\left.\\begin{array}{r}   1 &lt; x_i\\\\   x_i \\leq 4\\\\   x_i \\in \\{0,1,2,3,4,5\\}   \\end{array}\\right\\}\\quad\\Rightarrow   \\left.\\begin{array}{r}   1 &lt; x_i\\\\   x_i \\leq 4\\\\   x_i \\in \\{2,3,4\\}   \\end{array}\\right\\} \\] <p>Clearly, \\(x_i\\) cannot be 0 or 1 because of the first constraint, and it cannot be 5 because of the second constraint. After propagation, the variable's domain is reduced, and both constraints are node-consistent.</p> <p>Arc consistency (\\(m=2\\))</p> \\[   \\left.\\begin{array}{r}   x_i + 2x_j = 9\\\\   x_i \\in \\{0,1,2,3,4,5\\}\\\\   x_j \\in \\{0,1,2,3,4,5\\}   \\end{array}\\right\\}\\quad\\Rightarrow   \\left.\\begin{array}{r}   x_i + 2x_j = 9\\\\   x_i \\in \\{1,3,5\\}\\\\   x_j \\in \\{2,3,4\\}   \\end{array}\\right\\} \\] <p>Clearly, \\(x_i\\) cannot be even. Then the domain of \\(x_j\\) can also be reduced, because for values \\(0,1,5\\) there is no suitable value for \\(x_i\\) that satisfies the constraint. After this propagation, the constraint is arc-consistent.</p> <p>Local consistency for the <code>alldifferent</code> constraint</p> <p>The <code>alldifferent</code> constraint can be represented as a bipartite graph: variable nodes correspond to the variables, value nodes correspond to the possible values, and a variable node is connected to a value node if that value is in the variable's domain.</p> <p>Each matching that covers all variable nodes corresponds to a feasible assignment, and vice versa.</p> <p>Propagation: edges that do not appear in any matching can be removed, reducing the domains of the variables.</p>"},{"location":"cp/cp/#branch-and-propagate","title":"Branch-and-Propagate","text":"<p>If during propagation the domain of any variable becomes empty, it is proven that the problem has no solution.</p> <p>If, at the end of propagation, every variable's domain contains exactly one value, then that is the solution.</p> <p>Otherwise, propagation must be embedded into a tree search scheme, meaning that the problem has to be split into multiple subproblems (branches). For example, if a variable \\(x_i\\) has \\(k\\) possible values, say \\(D_i=\\{d_1,\\ldots,d_k\\}\\), we can create \\(k\\) branches, and in the \\(j\\)th branch, we require that \\(x_i = d_j\\).</p> Sudoku \u2013 Branch-and-Propagate <p>When we \"guessed\" in Sudoku \u2014 i.e., checked what would happen if we wrote a chosen number into a cell \u2014 we were basically performing a branching.</p>"},{"location":"cp/cp/#optimization","title":"Optimization","text":"<p>So far, we have not discussed optimization; we were only looking for a feasible solution. But what if we have an objective function? This can be handled in several ways, for example by an iterative approach: once a feasible solution is found, in the next iteration we add a constraint requiring the objective function value to be better than in the previous solution. For example, OR-Tools CP-SAT is a hybrid solver as it combines techniques from constraint programming, SAT solving, and mixed-integer programming.</p>"},{"location":"cp/queens/","title":"n-queens","text":"","tags":["cp","puzzle"]},{"location":"cp/queens/#rules","title":"Rules","text":"<p>Place \\(n\\) queens on an \\(n\\times n\\) chessboard in such a way that no two queens threaten each other (i.e., no two share a row, column, or diagonal).</p> <p>For example (\\(n=5\\)): <pre><code>\u00b7 \u00b7 \u2655 \u00b7 \u00b7\n\u00b7 \u00b7 \u00b7 \u00b7 \u2655\n\u00b7 \u2655 \u00b7 \u00b7 \u00b7\n\u00b7 \u00b7 \u00b7 \u2655 \u00b7\n\u2655 \u00b7 \u00b7 \u00b7 \u00b7\n</code></pre></p>","tags":["cp","puzzle"]},{"location":"cp/queens/#cp-formulation","title":"CP formulation","text":"<p>Rows and columns (more precisely ranks and files) are indexed from 1 to \\(n\\) (left to right and top to bottom, respectively).</p>","tags":["cp","puzzle"]},{"location":"cp/queens/#variables","title":"Variables","text":"<p>Let the variable \\(\\mathbf{x}_i\\) with domain \\(D_i = \\{1,\\ldots,n\\}\\) denote the column of the queen in row \\(i\\) (\\(i=1,\\ldots,n\\)). That is \\(\\mathbf{x}_i = j\\) if and only if there is a queen on square \\((i,j)\\).</p> <p>Remark</p> <p>Note that this definition uses the fact that there is exactly one queen in each row. It enforces the placement of exactly \\(n\\) queens on the board and guarantees that no two queens share a row.</p>","tags":["cp","puzzle"]},{"location":"cp/queens/#constraints","title":"Constraints","text":"<p>There is exactly one queen in each column:</p> \\[ \\operatorname{alldifferent}(\\mathbf{x}_1,\\ldots,\\mathbf{x}_n) \\] <p>Observation</p> <p>Queens on squares \\((i_1,j_1)\\) and \\((i_2,j_2)\\) share a diagonal if and only if \\(|i_1-i_2| = |j_1-j_2|\\), i.e., in terms of our variables, \\(|i_1-i_2| = |\\mathbf{x}_{i_1}-\\mathbf{x}_{i_2}|\\).</p> <p>There is at most one queen on each \"\\\" diagonal:</p> \\[ \\operatorname{alldifferent}(\\mathbf{x}_1,\\mathbf{x}_2 + 1,\\ldots,\\mathbf{x}_n+(n-1)) \\] <p>There is at most one queen on each \"/\" diagonal:</p> \\[ \\operatorname{alldifferent}(\\mathbf{x}_1,\\mathbf{x}_2 - 1,\\ldots,\\mathbf{x}_n-(n-1)) \\]","tags":["cp","puzzle"]},{"location":"cp/queens/#objective","title":"Objective","text":"<p>There is no objective, as this is a feasibility problem.</p> <p>Note that the problem is infeasible for certain values of \\(n\\) (for example, \\(n=2,3\\)).</p>","tags":["cp","puzzle"]},{"location":"cp/queens/#implementation","title":"Implementation","text":"<p>For the full code, see file <code>src/queens.py</code>.</p> <pre><code>from ortools.sat.python import cp_model\n\ndef solve_queens( n:int ) -&gt; None:\n    \"\"\"\n    Solves the n-queens puzzle as a CP with Google OR-Tools CP-SAT.\n\n    Args\n    ----\n    n : int\n        The size of the board (and the number of queens).\n    \"\"\"\n    # BUILD MODEL\n    model = cp_model.CpModel()\n\n    # variables: x[i] = j if and only if the queen of row i is in column j\n    # NOTE: by definition, there is only one queen in each row\n    x = [ model.new_int_var( 0, n-1, f'x_{i}' ) for i in range(n) ]\n\n    # constraints: queens cannot share columns\n    model.add_all_different( x )\n\n    # constraints: queens cannot share / diagonals\n    model.add_all_different( x[i] + i for i in range(n) )\n\n    # constraints: queens cannot share \\ diagonals\n    model.add_all_different( x[i] - i for i in range(n) )\n\n    # SOLVE PROBLEM\n    solver = cp_model.CpSolver()\n    status = solver.Solve( model )\n\n    print( f'status: {solver.status_name(status)} | total time: {solver.WallTime():.2f}' )\n\nif __name__ == '__main__':\n    solve_queens( 5 )\n</code></pre>","tags":["cp","puzzle"]},{"location":"cp/queens/#enumerating-all-solutions","title":"Enumerating all solutions","text":"<p>Sometimes, there are several solutions for a CSP. It is easy to see, that if we have a feasible placement of queens for an \\(n\\geq 4\\), we can obtain another solution by reflecting this placement. Sometimes rotation also yields a different solution.</p> <p>Constraint programming allows us to enumerate all feasible solutions of a problem. With OR-Tools CP-SAT it is very easy to make it: we just have to set the appropriate parameter before calling the solution process:</p> <pre><code>solver.parameters.enumerate_all_solutions = True\n</code></pre> <p>Solution callback</p> <p>In <code>src/cp/queens.py</code>, we define and set a callback \u2013 which are called by the solver for each feasible solution found \u2013 to print out solutions.</p>","tags":["cp","puzzle"]},{"location":"cp/rectangle/","title":"Rectangle packing","text":"<p>A set of rectangles must be packed into a container rectangle without overlaps. The rectangles must be aligned parallel to the container. If the total area of the rectangles equals the area of the container, this is called a perfect rectangle packing.</p> <p>A perfect squared square is a square that can be dissected into smaller squares of different sizes.</p>","tags":["cp","packing","interval variables","non-overlapping constraints"]},{"location":"cp/rectangle/#cp-formulation-without-rotation","title":"CP formulation (without rotation)","text":"<p>Let \\(\\mathcal{R} = \\{1,\\ldots,n\\}\\) be the set of rectangles, where</p> <ul> <li>\\(w_j\\) and \\(h_i\\) is the width and the height of the rectangle \\(j\\);</li> <li>\\(W_C\\) and \\(H_C\\) is the width and the height of the container rectangle \\(C\\).</li> </ul>","tags":["cp","packing","interval variables","non-overlapping constraints"]},{"location":"cp/rectangle/#variables","title":"Variables","text":"<p>Let variables \\(\\mathbf{x}_j\\) and \\(\\mathbf{y}_j\\) denote the coordinates of the bottom-left corner of rectangle \\(j\\in \\mathcal{R}\\) in the packing. Clearly, \\(0 \\leq \\mathbf{x}_j \\leq W_C - w_j\\) and \\(0 \\leq \\mathbf{y}_j \\leq H_C - h_j\\).</p> <p>Let the interval variables \\(\\mathbf{I}^x_j = [\\mathbf{x}_j,\\mathbf{x}_j + w_j]\\) and \\(\\mathbf{I}^y_j = [\\mathbf{y}_j,\\mathbf{y}_j + h_j]\\) associated with rectangle \\(j\\) express the projection of the rectangle (as intervals) onto the \\(x\\) and \\(y\\) axes, respectively.</p>","tags":["cp","packing","interval variables","non-overlapping constraints"]},{"location":"cp/rectangle/#constraints","title":"Constraints","text":"<p>Multi-dimensional non-overlapping constraints</p> <p>A disjoint constraint (or multi-dimensional non-overlapping constraint) ensures that the given rectangles (or more generally, orthotopes) do not overlap.</p> <p>For example, OR-Tools CP-SAT provides the constraint <code>add_no_overlap_2d</code> for two-dimensional intervals.</p> <p>Check the <code>diffn</code> (or <code>disjoint</code>) constraint in the Global Constraint Catalog.</p> <p>With such a constraint, we can easily formulate the packing constraints:</p> \\[ \\operatorname{disjoint}((\\mathbf{I}^x_1,\\ldots,\\mathbf{I}^x_n),(\\mathbf{I}^y_1,\\ldots,\\mathbf{I}^y_n)) \\]","tags":["cp","packing","interval variables","non-overlapping constraints"]},{"location":"cp/rectangle/#objective","title":"Objective","text":"<p>If we are certain that all rectangles can be packed, i.e., the problem is feasible, no objective function is needed. Otherwise, one can maximize the number of packed rectangles, which requires additional variables and constraints.</p>","tags":["cp","packing","interval variables","non-overlapping constraints"]},{"location":"cp/rectangle/#implementation","title":"Implementation","text":"<p>For the full code, see file <code>src/rectangle.py</code>.</p> <pre><code>def solve_rectangle_packing_without_rotation( container:tuple[int,int], rectangles:list[tuple[int,int]] ) -&gt; None:\n    \"\"\"\n    Solves the given instance of **Rectangle Packing without rotation** as a CP with **OR-Tools CP-SAT**.\n\n    Args\n    ----\n    container: tuple[int,int]\n        Size of the container as a (width,height) tuple.\n    rectangles: list[tuple[int,int]]\n        List of rectangles as (width,height) tuples.\n    \"\"\"\n    n = len(rectangles)\n\n    # BUILD MODEL\n    model = cp_model.CpModel()\n\n    # variables: x- and y-coordinates for the bottom-left corners\n    x = [ model.new_int_var( 0, container[0] - rectangles[i][0], f'x_{i}' ) for i in range(n) ]\n    y = [ model.new_int_var( 0, container[1] - rectangles[i][1], f'y_{i}' ) for i in range(n) ]\n\n    # variables: intervals for projection on x- and y-axes\n    xint = [ model.new_fixed_size_interval_var( x[i], rectangles[i][0], f'xint_{i}' ) for i in range(n) ]\n    yint = [ model.new_fixed_size_interval_var( y[i], rectangles[i][1], f'yint_{i}' ) for i in range(n) ]\n\n    # constraints: no overlap\n    model.add_no_overlap_2d( xint, yint )\n\n    # SOLVE PROBLEM\n    solver = cp_model.CpSolver()\n    status = solver.solve( model )\n\n    print( f'status: {solver.status_name(status)} | total time: {solver.WallTime():.2f}' )\n\n    if status in [cp_model.FEASIBLE, cp_model.OPTIMAL]:\n        draw_rectangle_packing( container, rectangles, [ ( solver.value(x[i]), solver.value(y[i]) ) for i in range(n) ] )\n</code></pre>","tags":["cp","packing","interval variables","non-overlapping constraints"]},{"location":"cp/rectangle/#exercises","title":"Exercises","text":"<ol> <li> <p>Modify function <code>solve_rectangle_packing_without_rotation</code> to maximize the number of packed rectangles (see the infeasible cases).</p> <p>Hint: use optional interval variables: <code>new_optional_fixed_size_interval_var</code>.</p> </li> <li> <p>Implement function <code>solve_rectangle_packing_with_rotation</code>, where rectangles can be rotated by 90 degrees.</p> <p>Hint: rectangle widths and heights are not fixed anymore (see, <code>new_int_var_from_domain</code> and <code>cp_model.Domain.from_values</code> along with <code>model.add_allowed_assignments</code>).</p> </li> </ol>","tags":["cp","packing","interval variables","non-overlapping constraints"]},{"location":"cp/scheduling/","title":"Machine Scheduling with Constraint Programming","text":"<p>Machine scheduling is about to schedule the processing of a set \\(\\mathcal{J}\\) of jobs on a set \\(\\mathcal{M}\\) of machines such that each machine can process at most one job at a time, and each job can be processed on at most one machine at a time. For a more detailed introduction, check the page Machine Scheduling.</p> <p>Here, we focus on a single-machine problem and solve it using constraint programming.  We will get familiar with the interval variables and the no-overlap constraints.</p>","tags":["cp","scheduling","interval variables","non-overlapping constraints"]},{"location":"cp/scheduling/#problem-definition","title":"Problem definition","text":"<p>We consider the problem \\(1|r_j|\\sum w_j C_j\\). That is, each job \\(j\\in\\mathcal{J}\\) has:</p> <ul> <li>a processing time \\(p_j\\),</li> <li>a priority weight \\(w_j\\),</li> <li>a release date \\(r_j\\),</li> </ul> <p>and the goal is to minimize the weighted sum of completion times.</p>","tags":["cp","scheduling","interval variables","non-overlapping constraints"]},{"location":"cp/scheduling/#cp-formulation","title":"CP formulation","text":"<p>Let \\(\\mathcal{J}=\\{1,\\ldots,n\\}\\).</p>","tags":["cp","scheduling","interval variables","non-overlapping constraints"]},{"location":"cp/scheduling/#variables-and-constraints","title":"Variables (and constraints)","text":"<p>Interval variables</p> <p>An interval variable allows to model an interval of time.</p> <p>Actually, it is both a variable and a constraint. It is a constraint, since it ties together multiple variables (start, duration, end, etc.) and enforces their relationships. It is a variable, since it can appear in multiple constraints.</p> <p>OR-Tools CP-SAT provides several types of interval variables, for example: <code>new_interval_var</code>, <code>new_fixed_size_interval_var</code>, <code>new_optional_interval_var</code>, and <code>new_optional_fixed_size_interval_var</code>.</p> <p>Let variables \\(\\mathbf{S}_j\\) and \\(\\mathbf{C}_j\\) denote the start and the completion of job \\(j \\in \\mahtcal{J}\\) and let \\(\\mathbf{I}_j = [\\mathbf{S}_j,\\mathbf{C}_j]\\) be the corresponding interval variable with fixed size \\(p_j\\). That is, \\(\\mathbf{C}_j = \\mathbf{S}_j + p_j\\) must hold.</p> <p>Let's notice that \\(\\operatorname{UB} = \\max_j r_j + \\sum_{j=1}^n p_j\\) is a valid upper bound on the makespan of the optimal schedule. Thus, we can use this value as an upper bound of the variables: \\(\\mathbf{S}_j \\in [r_j,\\operatorname{UB}-p_j]\\) and \\(\\mathbf{C}_j \\in [r_j+p_j,\\operatorname{UB}]\\).</p>","tags":["cp","scheduling","interval variables","non-overlapping constraints"]},{"location":"cp/scheduling/#constraints","title":"Constraints","text":"<p>Non-overlapping constraints</p> <p>A disjuncive constraint (or non-overlapping constraint) ensures that the given intervals do not overlap.</p> <p>For example, OR-Tools CP-SAT provides the constraint <code>add_no_overlap</code>.</p> <p>Check the <code>disjunctive</code> constraint in the Global Constraint Catalog.    </p> <p>With such a constraint, we can easily formulate the scheduling constraints:</p> \\[ \\operatorname{disjunctive}(\\mathbf{I}_1,\\ldots,\\mathbf{I}_n) \\]","tags":["cp","scheduling","interval variables","non-overlapping constraints"]},{"location":"cp/scheduling/#objective","title":"Objective","text":"<p>The objective is to minimize the weighted sum of completion times:</p> \\[ \\operatorname{minimize} \\sum_{j=1}^n w_j\\mathbf{C}_j \\]","tags":["cp","scheduling","interval variables","non-overlapping constraints"]},{"location":"cp/scheduling/#implementation","title":"Implementation","text":"<p>For the full code, see file <code>src/scheduling.py</code>.</p> <pre><code>def schedule_jobs_on_a_single_machine( processing_times:list[int], weights:list[int], release_times:list[int] ) -&gt; None:\n    \"\"\"\n    Solves scheduling problem \"1 | r_j | sum w_jC_j\" as a CP with OR-Tools CP-SAT.\n\n    Args\n    ----\n    processing_times: list[int]\n        List of processing times.\n    weights: list[int]\n        List of weights.\n    release_times: list[int]\n        List of release times.\n    \"\"\"\n    # INIT\n    n = len(processing_times)\n    UB = max(release_times) + sum(processing_times) # upper bound on the makespan\n\n    JOBS = range(n)\n\n    # BUILD MODEL\n    model = cp_model.CpModel()\n\n    # variables: interval variables ~ start times\n    jobs = [ model.new_fixed_size_interval_var(\n        start= model.new_int_var( release_times[i], UB, f'start_{i}' ),\n        size=  processing_times[i],\n        name=  f'job_{i}'\n    ) for i in JOBS ]\n\n    # constraint: jobs cannot overlap\n    model.add_no_overlap( jobs )\n\n    # objective: weighted sum of completion times\n    model.minimize( sum( weights[i] * jobs[i].end_expr() for i in JOBS ) )\n\n    # SOLVE PROBLEM\n    solver = cp_model.CpSolver()\n    #solver.parameters.log_search_progress = True\n    #solver.parameters.max_time_in_seconds = 30\n    status = solver.solve( model )\n\n    print( f'status: {solver.status_name(status)} | total time: {solver.WallTime():.2f} | objective: {int(solver.objective_value)}  (best lb: {int(solver.best_objective_bound)})' )\n\n    if status in [ cp_model.FEASIBLE, cp_model.OPTIMAL ]:\n        _print_schedule( processing_times, weights, release_times, [ solver.value(jobs[i].start_expr()) for i in JOBS ] )\n</code></pre>","tags":["cp","scheduling","interval variables","non-overlapping constraints"]},{"location":"cp/scheduling/#exercises","title":"Exercises","text":"<ol> <li> <p>Modify function <code>schedule_jobs_on_a_single_machine</code> to minimize the makespan of the schedule.</p> <p>Hint: check method/constraint <code>model.add_max_equality</code>.</p> </li> <li> <p>Implement function <code>schedule_jobs_on_identical_machines</code> to schedule jobs on identical parallel machines.</p> <p>Hint: use optional interval variables: <code>model.new_optional_fixed_size_interval_var</code>.</p> </li> <li> <p>Implement a function that solves a job-shop scheduling problem.</p> </li> <li> <p>Implement function _draw_schedule for GANTT chart vizualization (see Plotly, for an example).</p> </li> </ol>","tags":["cp","scheduling","interval variables","non-overlapping constraints"]},{"location":"cp/sudoku/","title":"Sudoku","text":"<p>Play online: www.puzzle-sudoku.com</p>","tags":["cp","puzzle"]},{"location":"cp/sudoku/#rules","title":"Rules","text":"<p>There is a grid of size \\(9\\times 9\\). The goal is to write a number from \\(1,\\ldots,9\\) in each cell, such that each column, each row, and each of the nine \\(3\\times 3\\) subgrids that compose the grid contains all numbers exactly once. Some numbers are pre-given.</p> <p>For example: <pre><code>Task:                         Solution:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 \u00b7 \u00b7 4 \u2502 6 \u00b7 \u00b7 \u2502 3 5 \u00b7 \u2502     \u2502 2 1 4 \u2502 6 8 7 \u2502 3 5 9 \u2502\n\u2502 \u00b7 \u00b7 \u00b7 \u2502 \u00b7 \u00b7 4 \u2502 \u00b7 \u00b7 7 \u2502     \u2502 5 9 3 \u2502 1 2 4 \u2502 6 8 7 \u2502\n\u2502 8 \u00b7 \u00b7 \u2502 5 \u00b7 \u00b7 \u2502 \u00b7 \u00b7 2 \u2502     \u2502 8 6 7 \u2502 5 3 9 \u2502 1 4 2 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1 \u00b7 5 \u2502 3 \u00b7 \u00b7 \u2502 \u00b7 6 \u00b7 \u2502     \u2502 1 7 5 \u2502 3 4 2 \u2502 9 6 8 \u2502\n\u2502 \u00b7 \u00b7 \u00b7 \u2502 \u00b7 \u00b7 \u00b7 \u2502 \u00b7 \u00b7 \u00b7 \u2502     \u2502 4 8 2 \u2502 7 9 6 \u2502 5 1 3 \u2502\n\u2502 \u00b7 3 \u00b7 \u2502 \u00b7 \u00b7 1 \u2502 2 \u00b7 4 \u2502     \u2502 6 3 9 \u2502 8 5 1 \u2502 2 7 4 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 7 \u00b7 \u00b7 \u2502 \u00b7 \u00b7 3 \u2502 \u00b7 \u00b7 1 \u2502     \u2502 7 5 8 \u2502 2 6 3 \u2502 4 9 1 \u2502\n\u2502 3 \u00b7 \u00b7 \u2502 9 \u00b7 \u00b7 \u2502 \u00b7 \u00b7 \u00b7 \u2502     \u2502 3 4 6 \u2502 9 1 8 \u2502 7 2 5 \u2502\n\u2502 \u00b7 2 1 \u2502 \u00b7 \u00b7 5 \u2502 8 \u00b7 \u00b7 \u2502     \u2502 9 2 1 \u2502 4 7 5 \u2502 8 3 6 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>","tags":["cp","puzzle"]},{"location":"cp/sudoku/#cp-formulation","title":"CP formulation","text":"<p>Rows and columns are indexed from 1 to 9 (left to right, and top to bottom, respectively). Let \\(G_{ij}\\) denote the pre-given number for cell \\((i,j)\\), if any, otherwise \\(G_{ij} = \\emptyset\\).</p>","tags":["cp","puzzle"]},{"location":"cp/sudoku/#variables","title":"Variables","text":"<p>Let variable \\(\\mathbf{x}_{ij}\\) indicate the number written into cell \\((i,j)\\). If cell \\((i,j)\\) is empty, the corresponding domain is \\(\\{1,\\ldots,9\\}\\), otherwise the variable is fixed to he given value.</p> \\[ D_{ij} =  \\begin{cases} \\{G_{ij}\\}     &amp; \\text{if }G_{ij} \\neq \\emptyset\\\\ \\{1,\\ldots,9\\} &amp; \\text{otherwise} \\end{cases} \\]","tags":["cp","puzzle"]},{"location":"cp/sudoku/#constraints","title":"Constraints","text":"<p>Each number occurs exactly once in a row:</p> \\[ \\operatorname{alldifferent}( \\mathbf{x}_{i,j} : j = 1,\\ldots,9 )\\quad \\text{for all}\\ i=1,\\ldots,9 \\] <p>Each number occurs exactly once in a column:</p> \\[ \\operatorname{alldifferent}( \\mathbf{x}_{i,j} : i = 1,\\ldots,9 )\\quad \\text{for all}\\ j=1,\\ldots,9 \\] <p>Each number occurs exactly once in a subgrid:</p> \\[ \\operatorname{alldifferent}( \\mathbf{x}_{i + i',j+j'} : i' = 0,1,2,\\ j' = 0,1,2 )\\quad \\text{for all}\\ i = 1,4,9,\\ j = 1,4,9 \\]","tags":["cp","puzzle"]},{"location":"cp/sudoku/#objective","title":"Objective","text":"<p>There is no objective, since it is a feasibility problem.</p>","tags":["cp","puzzle"]},{"location":"cp/sudoku/#implementation","title":"Implementation","text":"<p>For the full code, see file <code>src/sudoku.py</code>.</p>","tags":["cp","puzzle"]},{"location":"cp/sudoku/#input-format","title":"Input format","text":"<p>Instances are encoded as strings. For example, the instance shown above is given as: <pre><code>task = 'b4_6b3_5f4b7_8b5d2_1a5_3c6k3c1_2a4_7d3b1_3b9f2_1b5_8b'\n</code></pre></p> <p>The cells of the grid are stored consecutively (rows by rows) in this string. If a cell contains a number, then this number is written, otherwise, the number of empty cells until the next pre-given number (or until the end) is indicated with a single character (<code>'a'</code>: 1 empty cell,  <code>'b'</code>: 2 empty cells,  <code>'c'</code>: 3 empty cells, etc.). Note that this substring may contain underscores to separate adjacent numbers. For example, <code>'b4_6b'</code>.</p> <p>The following function decodes such a string: <pre><code>def _decode_sudoku_string( task:str ) -&gt; list[list[int]]:\n    \"\"\"\n    Decodes the given instance for Sudoku.\n\n    Args\n    ----\n    task : str\n        An instance for Sudoku encoded as a string, where:\n        - digits '1'-'9' represent filled cells\n        - letters 'a'-'z' represent consecutive empty cells\n        - optional underscores '_' may be used to separate digits\n\n    Returns\n    -------\n    grid : list[list[int]]\n        A 9x9 Sudoku grid as a list of row-lists.\n        Filled cells are integers, empty cells are None.\n    \"\"\"\n    cells = []\n\n    for char in task:\n        if char.isnumeric():\n            cells.append( int(char) )\n        elif char.isalpha():\n            cells.extend( None for _ in range(96,ord(char)) )\n        elif char == '_':\n            continue\n        else:\n            raise ValueError( f'could not decode task \"{task}\" due to unexpected character: \"{char}\"' )\n\n    assert len(cells) == 81, f'could not decode task \"{task}\" succesfully'\n\n    return [ cells[9*i:9*(i+1)] for i in range(9) ]\n</code></pre></p>","tags":["cp","puzzle"]},{"location":"cp/sudoku/#solver","title":"Solver","text":"<pre><code>import itertools as it\n\ndef _solve_sudoku( grid:list[list[int]] ) -&gt; list[list[int]]:\n    \"\"\"\n    Solves Sudoku as CP with OR-Tools CP-SAT.\n\n    Args\n    ----\n    grid : list[list[int]]\n        A 9x9 Sudoku grid as a list of row-lists.\n        Filled cells are integers, empty cells are None.\n\n    Returns\n    -------\n    grid : list[list[int]]\n        A 9x9 Sudoku grid as a list of row-lists.\n    \"\"\"\n    from ortools.sat.python import cp_model\n\n    n = 3 \n    N = range(n*n)\n\n    assert len(grid) == n*n, 'invalid matrix size!'\n\n    # BUILD MODEL\n    model = cp_model.CpModel()\n\n    # variables: x[i][j] = the number written into cell (i,j)\n    x = [ [ model.new_int_var( 1, n*n, f'x_{i}_{j}' ) for j in N ] for i in N ]\n\n    # constraints: pre-given numbers\n    for (i,j) in it.product(N,N):\n        if grid[i][j] != None:\n            model.add( x[i][j] == grid[i][j] )\n\n    # constraints: each number occurs exactly once in a row\n    for i in N:\n        model.add_all_different( x[i][j] for j in N )\n\n    # constraints: each number occurs exactly once in a column\n    for j in N:\n        model.add_all_different( x[i][j] for i in N )\n\n    # constraints: each number occurs exactly once in a 3x3 subgrid\n    for (p,q) in it.product(range(n),range(n)):\n       model.add_all_different( x[i+n*p][j+n*q] for (i,j) in it.product(range(n),range(n)) )\n\n    # SOLVE PROBLEM\n    solver = cp_model.CpSolver()\n    status = solver.solve( model )\n    assert status == cp_model.OPTIMAL, f'status: {solver.status_name(status)}'\n\n    # return solution\n    return [ [ solver.value(x[i][j]) for j in N ] for i in N ]\n</code></pre>","tags":["cp","puzzle"]},{"location":"intro/optimization/","title":"Optimization","text":"<p>Roughly speaking, optimization is about finding the best possible solution that satisfies certain requirements.</p> <p>Formally, if \\(\\mathcal{S}\\) is the set of feasible solutions, where each \\(S \\in \\mathcal{S}\\) solution has a cost \\(c(S)\\), then minimization can be expressed as:</p> \\[ \\operatorname{minimize} \\{ c(S) : S \\in \\mathcal{S} \\} \\] <p>In many graph optimization problems, feasible solutions are certain subsets of edges that satisfy a prescribed combinatorial structure. Let \\(G=(V,E)\\) be a graph with a cost function \\(c: E\\to \\mathbb{R}\\) defined on the edges. For any subset \\(S \\subseteq E\\) of edges, let \\(c(S) := \\sum_{e\\in S}c(e)\\). For example, in the shortest path problem, the goal is to find a minimum-cost path between two designated nodes \\(s\\) and \\(t\\). In this case, \\(\\mathcal{S}\\) is the set of all \\(s-t\\) paths in \\(G\\). In the traveling salesman problem, \\(\\mathcal{S}\\) is the set of all Hamiltonian cycles of the graph.</p> <p>In mathematical optimization, the set of feasible solutions is described using variables and constraints. Formally, there is a set \\(\\mathbf{x}_1,\\ldots,\\mathbf{x}_n\\) of variables, where each variable \\(\\mathbf{x}_i\\) has a domain \\(D_i\\); and a set \\(C_1,\\ldots,C_m\\) of constraints that restrict which combinations of variable values are allowed simultaneously. A feasible solution is an assignment of values to the variables that satisfies all constraints: $\\(\\mathcal{S} = \\{ (d_1,\\ldots,d_n) \\in D_1 \\times \\ldots, D_n : \\text{all constraints are satisified} \\}\\)$. The goal is usually to minimize (or maximize) an objective function of the variables. In constraint programming, constraints are typically logical conditions, while in linear and mixed-integer linear programming, constraints are expressed as linear inequalities.</p> <p>More detailed introduction: Constraint Programming</p>"},{"location":"intro/scheduling/","title":"Machine Scheduling - A brief introduction","text":"<p>A set \\(\\mathcal{J}\\) of jobs must be processed on a set \\(\\mathcal{M}\\) of machines such that each machine can process at most one job at a time, and each job can be processed on at most one machine at a time.</p> <p>Graham et al. (1979) introduced the 3-field problem classification \\(\\alpha | \\beta | \\gamma\\) for machine scheduling problems, where  the fields refer to the machine environment, the job characteristics, and the objective funtion, respectively. For example, \\(1|r_j|L_{\\max}\\) denotes the single machine problem, where each job has a release date, and the goal is to minimize the maximum lateness.</p> <p>Graham et al. (1979)</p> <p>Graham, R. L., Lawler, E. L., Lenstra, J. K., &amp; Kan, A. R. (1979). Optimization and approximation in deterministic sequencing and scheduling: a survey. In Annals of discrete mathematics (Vol. 5, pp. 287-326). Elsevier.</p> <p>The Scheduling Zoo</p> <p>The Scheduling Zoo is an excellent website where you can look up the complexity of machine scheduling problems.</p>","tags":["scheduling"]},{"location":"intro/scheduling/#machine-environment-alpha","title":"Machine environment (\\(\\alpha\\))","text":"<p>\\(\\alpha = 1\\) refers to the single machine case.</p> <p>\\(\\alpha \\in \\{ \\operatorname{P}, \\operatorname{R}, \\operatorname{Q} \\}\\) refers to parallel machines, where each job must be assigned to and processed on exactly one machine. The processing time of job \\(j\\) on machine \\(i\\) is \\(p_{ij}\\). In case of identical parallel machines, \\(\\alpha = \\operatorname{P}\\), the processing time of a job is the same for all machines, that is, \\(p_{ij} = p_j\\) for all \\(i\\). In case of uniform parallel machines (or related machines), \\(\\alpha = \\operatorname{Q}\\), each machine \\(i\\) has a speed factor \\(q_i\\), and the processing time of a job \\(j\\) on a machine \\(i\\) is \\(p_{ij} = q_ip_j\\). In case of unrelated parallel machines, \\(\\alpha = \\operatorname{R}\\), there are no such relationship between the processing times.</p> <p>\\(\\alpha \\in \\{ \\operatorname{O}, \\operatorname{F}, \\operatorname{J} \\}\\) refers to shop problems, where each job \\(j\\) consists of a set \\((O_{1j},\\ldots,O_{mj})\\) of operations, such that the operation \\(O_{ij}\\) must be processed on machine \\(i\\) with processing time \\(p_{ij}\\). In case of open shop, \\(\\alpha=\\operatorname{O}\\), the operations can be scheduled in any order. In case of flow shop, \\(\\alpha=\\operatorname{F}\\), the operations must be scheduled in a given order. In case of job shop, \\(\\alpha=\\operatorname{J}\\), the operations must be scheduled in a given order, and this order is the same for all jobs.</p> <p>In case of multiple machines, if the number of the machines, \\(m\\), is fixed, it is indicated in the environment. For example, \\(P2\\), \\(F3\\), \\(Jm\\), etc.</p> Environment \\(\\alpha\\) Description Single machine 1 Single machine. Identical parallel machines P Parallel machines. The processing time of a job is the same for all machines. Uniform parallel machines Q Parallel machines. The processing time of a job depends on the speed of the machine. Related machines R Parallel machines. Open shop O Shop problem. Flow shop F Shop problem. Operation order is fixed for each job. Job shop J Shop problem. Operation order is fixed, and the same for all jobs.","tags":["scheduling"]},{"location":"intro/scheduling/#constraints-beta","title":"Constraints (\\(\\beta\\))","text":"<p>The processing times (\\(p_{ij}\\) or \\(p_{j}\\)) are always given, thus their presence is never indicated in the \\(\\beta\\)-field, Each job \\(j\\) may have a due date \\(d_j\\), by which it should ideally be completed. Each job \\(j\\) may also be associated with a weight priority \\(w_j\\).  Parameters \\(d_j\\) and \\(w_j\\) are never indicated in the \\(\\beta\\)-field; if the objective function requires them, we simply assume they are given.</p> <p>Several constraints can be indicated in the \\(\\beta\\)-field. Here, we present a few examples that will be used later.</p> <p>Jobs may be associated with a release date \\(r_j\\), indicating their earliest possible start time.</p> <p>Jobs (or operations) may require a preparation time. In case of sequence-dependent setup times, preparation times depend on the predecessor job (or operation), if any.</p> Constraint \\(\\beta\\) Description Release times \\(r_j\\) Earliest start times for jobs. Sequence-dependent setup times \\(sds\\) Changing time between jobs.","tags":["scheduling"]},{"location":"intro/scheduling/#objective-function-gamma","title":"Objective function (\\(\\gamma\\))","text":"<p>For a given schedule \\(S\\), let \\(C^S_j\\) denote the completion time of job \\(j\\). Note that, in the non-preemptive case, the assignment of jobs to machines together with their completion times fully describes the schedule.</p> <p>The makespan of the schudule is the maximum completion time of the jobs: \\(C^S_{\\max} = \\max_{j \\in \\mathcal{J}}C^S_j\\). The lateness of a job \\(j\\) is \\(L^S_j = C^S_j - d_j\\), while its tardiness is \\(T^S_j = \\max\\{0,L^S_j\\}\\). Let \\(U^S_j = 1\\) if job \\(j\\) is late (i.e., \\(0 &lt; L^S_j\\)), and 0 otherwise.</p> <p>The flow time of a job \\(j\\) is \\(F^S_j = C^S_j - r_j\\).</p> Objective (\\(\\gamma\\)) Description \\(C_{\\max}\\) Minimizing the makespan, i.e., the maximum completion time. \\(\\sum C_j\\) Minimizing the sum of completion times. \\(\\sum w_jC_j\\) Minimizing the weighted sum of completion times. \\(L_{\\max}\\) Minimizing the maximum lateness. \\(\\sum T_j\\) Minimizing the total tardiness. \\(\\sum w_jT_j\\) Minimizing the weighted tardiness. \\(\\sum U_j\\) Maximizing the throughput, that is, minimizing the number of late jobs. \\(\\sum w_jU_j\\) Maximizing the weighted throughput, that is, minimizing the total weight of late jobs. \\(\\sum F_j\\) Minimizing the maximum flow time.","tags":["scheduling"]},{"location":"puzzles/puzzles/","title":"Puzzles","text":"<p>Puzzles provide a fun way to get hands-on experience with CP/MIP formulations and solvers.</p>"},{"location":"puzzles/puzzles/#thermometers","title":"Thermometers","text":"<p>There is a grid of size \\(n\\times n\\), where the cells are covered by thermometers. The goal is to fill some thermometers with mercury starting from the bulb and going toward the end without gaps. The clue values on the top and on the left side indicate the number of filled cells horizontally and vertically, respectively.</p> <pre><code>Task:       Solution:\n   3211        3211\n 2 \u2576\u2574\u2576\u2510      2   \u2576\u2510\n 1 \u2577\u250c\u2574\u2575      1 \u2577\n 2 \u2502\u2575\u2576\u2574      2 \u2502\u2575\n 2 \u2514\u2500\u2500\u2574      2 \u2514\u2500\n</code></pre> <p>Thermometers instances are encoded as strings as follows. For example, the instance shown above is given as: <pre><code>thermometers_instance = '3_2_1_1_2_1_2_2;1,2;5,2,3,7;5,4,8,12,13,14,15;5,9,5,6;1,2'\n</code></pre> The first part of the string (i.e., the substring until the first semicolon) refers to the \\(2n\\) clue values for columns (left to right) and for rows (top to bottom) separated by underscores. The second part of the string refers to the thermometers, separated by semicolons. Each thermometer is given as a sequence of numbers, separated by commas, where the first number indicates the type of the thermometer.</p> <ul> <li>Curved thermometers are indicated with type <code>'5'</code>, which is followed by the explicit description of the corresponding cell sequence. Note that the cells are number from 1 to \\(n^2\\) in row-major order (i.e., left to right and top to bottom).</li> <li>Straight thermometers are indicited with types <code>'1'</code>-<code>'4'</code>, which describe their direction (1: horizontal, left to right; 2: horizontal, right to left; 3: vertical, top to bottom; 4: vertical, bottom to top). Each straight thermometers starts (types <code>'1'</code>, <code>'3'</code>) or ends (types <code>'2'</code>, <code>'4'</code>) in the first cell, which is not occupied by a former thermometer.</li> </ul> <p>File <code>src/puzzles/thermometers.py</code> contains a decoding method for Thermometers instances.</p>"},{"location":"puzzles/puzzles/#kakurasu","title":"Kakurasu","text":"<p>Given an \\(n\\times n\\) grid with target values assigned to each row and column. The goal is to mark (for example, shade) some cells so that the sum of the indices of the marked cells in every row and column matches the given target values.</p> <pre><code>Instance:         Solution:      \n    1 2 3 4           1 2 3 4    \n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \n1 \u2502         \u2502 5   1 \u2502 \u00d7     \u00d7 \u2502 5   indices: top and left\n2 \u2502         \u2502 4   2 \u2502       \u00d7 \u2502 4   target values: bottom and right\n3 \u2502         \u2502 2   3 \u2502   \u00d7     \u2502 2\n4 \u2502         \u2502 8   4 \u2502 \u00d7   \u00d7 \u00d7 \u2502 8\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \n    5 3 4 7           5 3 4 7    \n</code></pre> <p>Kakurasu instances are encoded as strings that consist of the target values for columns (from left to right) and for rows (from top to bottom) separated by slashes <code>'/'</code>. For example, the instance shown above is encoded as: <pre><code>kakurasu_instance = '5/3/4/7/5/4/2/8'\n</code></pre></p> <p>File <code>src/puzzles/kakurasu.py</code> contains a decoding method for Kakurasu instances.</p>"},{"location":"puzzles/puzzles/#skyscrapers-skylines-towers","title":"Skyscrapers (Skylines, Towers)","text":"<p>Given an \\(n\\times n\\) grid with clues along the edges (top, bottom, left, right) and some pre-filled cells. The goal is to fill the remaining cells with numbers \\(1,\\ldots,n\\) \u2013 representing skyscrapers of that heights \u2013 such that:</p> <ul> <li>each number appears exactly once in every row and every column;</li> <li>each edge clue indicates how many skyscrapers are visible from that direction in the corresponding row or column. Note that a taller skyscraper blocks the view of any shorter skyscraper behind it.</li> </ul> <pre><code>Instance:           Solution:       \n          2                   2      \n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \n4 \u2502 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u2502     4 \u2502 2 1 3 4 5 \u2502  \n  \u2502 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u2502 4     \u2502 5 4 1 3 2 \u2502 4\n  \u2502 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u2502       \u2502 4 2 5 1 3 \u2502  \n  \u2502 \u00b7 \u00b7 \u00b7 \u00b7 1 \u2502       \u2502 1 3 2 5 4 \u2502  \n  \u2502 \u00b7 \u00b7 2 \u00b7 \u00b7 \u2502       \u2502 3 5 4 2 1 \u2502  \n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \n    3     2             3     2      \n</code></pre> <p>Skyscrapers instances are encoded as strings, as follows. The string consists of one or two parts, separated by a comma <code>','</code> in the latter case. The first part encodes the clues for columns (top and bottom, from left to right) and for rows (left and right, from top to bottom), separated by slashes <code>'/'</code>, using <code>''</code> for missing clues. The optional second part encodes the grid itself. Cells are listed in row-major order (i.e., left to right and top to bottom). If a cell contains a number, the number is written directly; if it is empty, the number of consecutive empty cells until the next pre-given number (or until the end) is represented by a single character: <code>'a'</code> for 1 empty cell, <code>'b'</code> for 2 empty cells, <code>'c'</code> for 3 empty cells, etc. Underscores <code>'_'</code> can optionally be used to separate adjacent numbers for readability. For example, the instance shown above is encoded as: <pre><code>skyscrapers_instance = '///2//3///2//4//////4///,s1b2b'\n</code></pre></p> <p>File <code>src/puzzles/skyscrapers.py</code> contains a decoding method for Skyscrapers instances.</p>"},{"location":"puzzles/puzzles/#binario-takuzu","title":"Binario (Takuzu)","text":"<p>Given a \\(2n \\times 2n\\) grid, some cells may already be filled with black or white circles. The goal is to fill the remaining cells with black and white circles so that:</p> <ul> <li>each row and each column contains exactly \\(n\\) black circles and \\(n\\) white circles;</li> <li>no row or column contains three consecutive circles of the same color;</li> <li>all rows are pairwise distinct, and all columns are pairwise distinct.</li> </ul> <pre><code>Instance:       Solution:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \n\u2502 0 0 \u00b7 \u00b7 \u00b7 \u00b7 \u2502 \u2502 0 0 1 0 1 1 \u2502  0: white circle\n\u2502 \u00b7 \u00b7 1 \u00b7 \u00b7 \u00b7 \u2502 \u2502 1 0 1 0 1 0 \u2502  1: black circle\n\u2502 1 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u2502 \u2502 1 1 0 1 0 0 \u2502\n\u2502 \u00b7 \u00b7 \u00b7 1 \u00b7 \u00b7 \u2502 \u2502 0 0 1 1 0 1 \u2502\n\u2502 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u00b7 \u2502 \u2502 1 1 0 0 1 0 \u2502\n\u2502 \u00b7 1 \u00b7 \u00b7 0 1 \u2502 \u2502 0 1 0 1 0 1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Binario instances are encoded as strings, as follows. Cells are listed in row-major order (i.e., left to right and top to bottom). If a cell contains a white or black circle, the character <code>'0'</code> or <code>'1'</code> is written, respectively. If a cell is empty, the number of consecutive empty cells until the next number (or until the end) is represented by a single character: <code>'a'</code> for 1 empty cell, <code>'b'</code> for 2 empty cells, <code>'c'</code> for 3 empty cells, etc. For example, the instance shown above is encoded as: <pre><code>binario_instance = '00f1c1h1i1b01'\n</code></pre></p> <p>File <code>src/puzzles/binario.py</code> contains a decoding method for Binario instances.</p>"},{"location":"puzzles/puzzles/#slitherlink-loops-fences","title":"Slitherlink (Loops, Fences)","text":"<p>Given an \\(n \\times n\\) grid, where some cells contain a number from 0 to 3. The goal is to draw a single non-crossing loop along the edges of the cells such that the number in each cell indicates how many of its sides are crossed by the loop.</p> <pre><code>Instance:                 Solution:\n\u00b7   \u00b7   \u00b7   \u00b7   \u00b7   \u00b7     \u00b7   \u250c\u2500\u2500\u2500\u2510   \u00b7   \u250c\u2500\u2500\u2500\u2510 \n  2       1   2             2 \u2502   \u2502 1   2 \u2502   \u2502 \n\u00b7   \u00b7   \u00b7   \u00b7   \u00b7   \u00b7     \u250c\u2500\u2500\u2500\u2518   \u2502   \u250c\u2500\u2500\u2500\u2518   \u2502 \n  3   1                   \u2502 3   1 \u2502   \u2502       \u2502 \n\u00b7   \u00b7   \u00b7   \u00b7   \u00b7   \u00b7     \u2514\u2500\u2500\u2500\u2510   \u2514\u2500\u2500\u2500\u2518   \u250c\u2500\u2500\u2500\u2518 \n  3           1             3 \u2502         1 \u2502     \n\u00b7   \u00b7   \u00b7   \u00b7   \u00b7   \u00b7     \u250c\u2500\u2500\u2500\u2518   \u250c\u2500\u2500\u2500\u2510   \u2514\u2500\u2500\u2500\u2510 \n  2               2       \u2502 2     \u2502   \u2502     2 \u2502 \n\u00b7   \u00b7   \u00b7   \u00b7   \u00b7   \u00b7     \u2502   \u250c\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2510   \u2502 \n      2   0   2           \u2502   \u2502 2   0   2 \u2502   \u2502 \n\u00b7   \u00b7   \u00b7   \u00b7   \u00b7   \u00b7     \u2514\u2500\u2500\u2500\u2518   \u00b7   \u00b7   \u2514\u2500\u2500\u2500\u2518 \n</code></pre> <p>Slitherlink instances are encoded as strings, as follows. Cells are listed in row-major order (i.e., left to right and top to bottom). If a cell contains a number, the number is written directly; if it is empty, the number of consecutive empty cells until the next number (or until the end) is represented by a single character: <code>'a'</code> for 1 empty cell, <code>'b'</code> for 2 empty cells, <code>'c'</code> for 3 empty cells, etc. For example, the instance shown above is encoded as: <pre><code>slitherlink_instance = '2a12a31c3b1a2c2a202a'\n</code></pre></p>"},{"location":"puzzles/puzzles/#hashi-bridges","title":"Hashi (Bridges)","text":"<p>Given an \\(n\\times n\\) grid, where some cells contain a number between 1 and 8 representing islands. The goal is to connect all islands into a single connected group using bridges, such that:</p> <ul> <li>each bridge connects exactly two islands in a straight line;</li> <li>bridges run only horizontally or vertically;</li> <li>bridges cannot cross other bridges or islands;</li> <li>at most two bridges can connect any pair of islands;</li> <li>the number of bridges connected to each island must equal the number written on that island.</li> </ul> <pre><code>Instance:                      Solution:\n\u00b7   4   \u00b7   \u00b7   \u00b7   \u00b7   3      \u00b7   4 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 3\n                                   \u2551                   \u2502\n2   \u00b7   4   \u00b7   \u00b7   4   \u00b7      2   \u2551   4 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 4   \u2502\n                               \u2551   \u2551   \u2551           \u2551   \u2502\n\u00b7   2   \u00b7   \u00b7   \u00b7   \u00b7   \u00b7      \u2551   2   \u2551   \u00b7   \u00b7   \u2551   \u2502\n                               \u2551       \u2551           \u2551   \u2502\n\u00b7   \u00b7   \u00b7   \u00b7   \u00b7   2   \u00b7      \u2551   \u00b7   \u2551   \u00b7   \u00b7   2   \u2502\n                               \u2551       \u2551               \u2502\n3   \u00b7   4   \u00b7   \u00b7   \u00b7   4      3 \u2500\u2500\u2500\u2500\u2500 4 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 4\n                                                       \u2551\n\u00b7   \u00b7   \u00b7   \u00b7   \u00b7   \u00b7   \u00b7      \u00b7   \u00b7   \u00b7   \u00b7   \u00b7   \u00b7   \u2551\n                                                       \u2551\n\u00b7   1   \u00b7   2   \u00b7   \u00b7   3      \u00b7   1 \u2500\u2500\u2500\u2500\u2500 2 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 3\n</code></pre> <p>Hashi instances are encoded as strings, as follows. Cells are listed in row-major order (i.e., left to right and top to bottom). If a cell contains a number, the number is written directly; if it is empty, the number of consecutive empty cells until the next number (or until the end) is represented by a single character: <code>'a'</code> for 1 empty cell, <code>'b'</code> for 2 empty cells, <code>'c'</code> for 3 empty cells, etc. For example, the instance shown above is encoded as: <pre><code>hashi_instance = 'a4d32a4b4b2j2a3a4c4h1a2b3'\n</code></pre></p>"},{"location":"puzzles/puzzles/#masyu","title":"Masyu","text":"<p>Given an \\(n\\times n\\) grid, where some cells contain a black or a white circle. The goal is to draw a single non-crossing loop that passes through all the circles, such that</p> <ul> <li>the loop moves only along the centers of cells, horizontally or vertically;</li> <li>the loop must turn on black circles, and must go straight in the cells immediately before and after each black circle;</li> <li>the loop must go straight through white circles, and must turn in at least one of the cells immediately before or after each white circle.</li> </ul> <pre><code>Instance:                  Solution:            \n\u00b7   \u00b7   \u00b7   \u00b7   W   B      \u250c\u2500\u2500\u2500\u2510   \u00b7   \u250c\u2500\u2500 W \u2500 B      W: white circle \n                           \u2502   \u2502       \u2502       \u2502      B: black circle\nW   \u00b7   W   \u00b7   \u00b7   W      W   \u2514\u2500\u2500 W \u2500\u2500\u2518   \u00b7   W\n                           \u2502                   \u2502\n\u00b7   \u00b7   \u00b7   B   \u00b7   \u00b7      \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500 B   \u250c\u2500\u2500\u2500\u2518\n                           \u2502   \u2502       \u2502   \u2502    \n\u00b7   W   \u00b7   W   W   \u00b7      \u2502   W   \u00b7   W   W   \u00b7\n                           \u2502   \u2502       \u2502   \u2502    \nW   W   \u00b7   \u00b7   \u00b7   \u00b7      W   W   \u00b7   \u2502   \u2514\u2500\u2500\u2500\u2510\n                           \u2502   \u2502       \u2502       \u2502\n\u00b7   \u00b7   \u00b7   B   \u00b7   \u00b7      \u2514\u2500\u2500\u2500\u2518   \u00b7   B \u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Masyu instances are encoded as strings, as follows. Cells are listed in row-major order (i.e., left to right and top to bottom). If a cell contains a white or a black circle, the upper case letter <code>'W'</code> or <code>'B'</code> is written, respectively; if it is empty, the number of consecutive empty cells until the next number (or until the end) is represented by a single lower case letter: <code>'a'</code> for 1 empty cell, <code>'b'</code> for 2 empty cells, <code>'c'</code> for 3 empty cells, etc. For example, the instance shown above is encoded as: <pre><code>masyu_instance = 'dWBWaWbWcBcWaWWaWWgBb'\n</code></pre></p>"},{"location":"puzzles/puzzles/#hitori","title":"Hitori","text":"<p>Given an \\(n\\times n\\) grid where each cell contains a number from \\(1\\) to \\(n\\). The goal is to mark (for example, shade) some cells such that:</p> <ul> <li>in every row and column, the unmarked numbers are all distinct;</li> <li>marked cells cannot be adjacent horizontally or vertically;</li> <li>all unmarked cells form a single connected group.</li> </ul> <pre><code>Instance:     Solution:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 1 5 4 4 3 \u2502 \u2502 1 5 \u2592 4 \u2592 \u2502\n\u2502 3 3 1 2 5 \u2502 \u2502 \u2592 3 1 2 5 \u2502\n\u2502 3 1 1 5 3 \u2502 \u2502 3 1 \u2592 5 \u2592 \u2502\n\u2502 1 2 4 3 1 \u2502 \u2502 \u2592 2 4 3 1 \u2502\n\u2502 2 4 5 5 3 \u2502 \u2502 2 4 5 \u2592 3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Hitori instances are encoded as strings, where cells are listed in row-major order (i.e., left to right and top to bottom). For example, the instance shown above is encoded as: <pre><code>hitori_instance = '1544333125311531243124553'\n</code></pre></p>"},{"location":"puzzles/puzzles/#pipes","title":"Pipes","text":"<p>Given an \\(n\\times n\\) grid where each cell contains a pipe tile. The goal is to rotate the tiles so that they form a single connected network without cycles.</p> <pre><code>Instance:    Solution:\n\u2575\u2574\u2575\u2518         \u2577\u2577\u2576\u2510 \n\u252c\u251c\u2500\u2534         \u251c\u2534\u2500\u2524 \n\u2574\u2518\u252c\u252c         \u2575\u250c\u252c\u2524 \n\u2577\u2514\u2577\u2574         \u2576\u2518\u2575\u2575 \n</code></pre> <p>Pipes instances are encoded as strings, where cells (with the following tile-encoding) are listed in row-major order (i.e., left to right and top to bottom).</p> char tile description char tile description 1 \u2576 sink     (r) 8 \u2577 sink     (d) 2 \u2575 sink     (u) 9 \u250c curve    (rd) 3 \u2514 curve    (ru) a \u2502 straight (ud) 4 \u2574 sink     (l) b \u251c branch   (rud) 5 \u2500 straight (rl) c \u2510 curve    (ld) 6 \u2518 curve    (ul) d \u252c branch   (rld) 7 \u2534 branch   (rul) e \u2524 branch   (uld) <p>Tile-encoding</p> <p>The tile-encoding is systematic, not ad-hoc.</p> <p>For example, the instance shown above is encoded as: <pre><code>pipes_instance = '2426db5746dd8384'\n</code></pre></p>"}]}